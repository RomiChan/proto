package main

import (
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strconv"
	"strings"
)

func setOf(ss ...string) map[string]bool {
	set := make(map[string]bool)
	for _, s := range ss {
		set[s] = true
	}
	return set
}

var needTransform = setOf(
	"bool", "string",
	"float32", "float64",
	"int32", "int64", "uint32", "uint64",
	"fixed32", "fixed64", "zigzag32", "zigzag64",
)

func main() {
	fs := token.NewFileSet()
	f, err := parser.ParseFile(fs, "normal_codec.go", nil, parser.AllErrors)
	if err != nil {
		panic(err)
	}
	transform(f)
	outfs := token.NewFileSet()
	outfile, _ := os.OpenFile("required_codec.go", os.O_WRONLY|os.O_CREATE|os.O_SYNC|os.O_TRUNC, 0o644)
	io.WriteString(outfile, "// Code generated by gen/gen_decode.go. DO NOT EDIT.\n\n")
	err = format.Node(outfile, outfs, f)
	if err != nil {
		panic(err)
	}
}

func transform(f *ast.File) {
	var newDecl []ast.Decl
	for _, decl := range f.Decls {
		switch decl := decl.(type) {
		case *ast.FuncDecl:
			if decl.Recv != nil {
				return
			}
			name := decl.Name.Name
			switch {
			case strings.HasPrefix(name, "size"):
				fallthrough
			case strings.HasPrefix(name, "encode"):
				name = strings.TrimPrefix(name, "sizeOf")
				name = strings.TrimPrefix(name, "encode")
				name = strings.ToLower(name)
				if !needTransform[name] {
					continue
				}
				decl.Name.Name += "Required"
				transformFuncBody(decl.Body)
				newDecl = append(newDecl, decl)
			}
		case *ast.GenDecl:
			switch decl.Tok {
			case token.IMPORT:
				filterImport(decl)
				newDecl = append(newDecl, decl)
			case token.VAR:
				transformVar(decl)
				if decl.Specs != nil {
					newDecl = append(newDecl, decl)
				}
			}
		}
	}
	f.Decls = newDecl
}

func filterImport(decl *ast.GenDecl) {
	specs := make([]ast.Spec, 0, len(decl.Specs))
	for _, spec := range decl.Specs {
		spec := spec.(*ast.ImportSpec)
		unquote, err := strconv.Unquote(spec.Path.Value)
		if err != nil {
			continue
		}
		switch unquote {
		case "io":
		default:
			specs = append(specs, spec)
		}
	}
	decl.Specs = specs
}

func transformVar(decl *ast.GenDecl) {
	if decl.Tok != token.VAR {
		return
	}
	var specs []ast.Spec
	for _, spec := range decl.Specs {
		val := spec.(*ast.ValueSpec)
		if len(val.Names) != 1 {
			continue
		}
		name := strings.TrimSuffix(val.Names[0].Name, "Codec")
		if !needTransform[strings.TrimSuffix(name, "Codec")] {
			continue
		}
		val.Names[0].Name = strings.TrimSuffix(name, "Codec") + "RequiredCodec"
		value := val.Values[0].(*ast.CompositeLit)
		for _, elem := range value.Elts {
			elem := elem.(*ast.KeyValueExpr)
			ident := elem.Value.(*ast.Ident)
			if elem.Key.(*ast.Ident).Name != "decode" {
				ident.Name = ident.Name + "Required"
			}
		}
		specs = append(specs, val)
	}
	decl.Specs = specs
}

func transformFuncBody(body *ast.BlockStmt) {
	var out []ast.Stmt
	var returned bool
	enqueue := func(block *ast.BlockStmt) {
		for _, stmt := range block.List {
			out = append(out, stmt)
			if _, ok := stmt.(*ast.ReturnStmt); ok {
				returned = true
			}
		}
	}

	for _, stmt := range body.List {
		if returned {
			break
		}
		switch stmt := stmt.(type) {
		default:
			out = append(out, stmt)
		case *ast.IfStmt:
			if stmt.Init != nil {
				out = append(out, stmt.Init)
			}
			enqueue(stmt.Body)
		}
	}
	body.List = out
}
